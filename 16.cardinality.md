# SQL Server Cardinality

## Table of Contents
1. [Introduction to Cardinality](#1-introduction-to-cardinality)
2. [Types of Cardinality](#types-of-cardinality)
   - 2.1 [One-to-One (1:1)](#one-to-one-1-1)
   - 2.2 [One-to-Many (1:N)](#one-to-many-1-n)
   - 2.3 [Many-to-Many (M:N)](#many-to-many-m-n)
3. [Cardinality in SQL Server](#cardinality-in-sql-server)
4. [Cardinality Estimation](#cardinality-estimation)
   - 4.1 [How SQL Server Estimates Cardinality](#how-sql-server-estimates-cardinality)
   - 4.2 [Cardinality Estimator Versions](#cardinality-estimator-versions)
5. [Examples and Use Cases](#examples-and-use-cases)
   - 5.1 [One-to-One Relationship](#one-to-one-relationship)
   - 5.2 [One-to-Many Relationship](#one-to-many-relationship)
   - 5.3 [Many-to-Many Relationship](#many-to-many-relationship)
6. [Best Practices](#best-practices)
7. [Troubleshooting Cardinality Issues](#troubleshooting-cardinality-issues)
8. [Conclusion](#conclusion)
9. [References](#references)

---

## 1. Introduction to Cardinality
Cardinality refers to the uniqueness of data values contained in a column or a set of columns. It is an important concept in database design and query optimization, as it affects the performance and accuracy of queries. High cardinality means the data has a large number of unique values, while low cardinality means fewer unique values.

## 2. Types of Cardinality

### 2.1 One-to-One (1:1)
In a one-to-one relationship, each row in a table is linked to one and only one row in another table. This type of relationship is less common and is often used when you need to split a table for security or organizational reasons.

### 2.2 One-to-Many (1:N)
The most common relationship type, where a single row in one table can be related to multiple rows in another table. For example, a single customer can have multiple orders.

### 2.3 Many-to-Many (M:N)
In a many-to-many relationship, rows in one table can relate to multiple rows in another table, and vice versa. This relationship typically requires a junction table to resolve.

## 3. Cardinality in SQL Server
In SQL Server, cardinality plays a crucial role in query execution plans. The SQL Server query optimizer uses cardinality estimates to decide on the best execution plan for a query. Misestimations can lead to inefficient queries, resulting in slower performance.

## 4. Cardinality Estimation

### 4.1 How SQL Server Estimates Cardinality
SQL Server uses statistical data to estimate the cardinality of a query result. This estimation is based on the number of rows, distribution of data, and relationships between tables.

### 4.2 Cardinality Estimator Versions
SQL Server introduced a new cardinality estimator in SQL Server 2014. This new estimator improves query performance by better handling modern workloads, but it may cause regressions in some queries. It is important to test and compare the performance of your queries with both estimators.

## 5. Examples and Use Cases

### 5.1 One-to-One Relationship
**Example:**
```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(100),
    Position VARCHAR(100)
);

CREATE TABLE EmployeeDetails (
    EmployeeID INT PRIMARY KEY,
    Address VARCHAR(255),
    Phone VARCHAR(20),
    FOREIGN KEY (EmployeeID) REFERENCES Employees(EmployeeID)
);
```
**Use Case:** 
This relationship could be used to store sensitive information like employee details separately from general employee data.

### 5.2 One-to-Many Relationship
**Example:**
```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(100)
);

CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    OrderDate DATE,
    CustomerID INT,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);
```
**Use Case:** 
This setup is ideal for scenarios like an e-commerce platform where a customer can place multiple orders.

### 5.3 Many-to-Many Relationship
**Example:**
```sql
CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    StudentName VARCHAR(100)
);

CREATE TABLE Courses (
    CourseID INT PRIMARY KEY,
    CourseName VARCHAR(100)
);

CREATE TABLE StudentCourses (
    StudentID INT,
    CourseID INT,
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
);
```
**Use Case:** 
Used in educational databases where students can enroll in multiple courses, and each course can have multiple students.

## 6. Best Practices
- Regularly update statistics to ensure accurate cardinality estimates.
- Use indexed views to improve query performance in cases of complex joins.
- Consider the impact of query hints on cardinality estimates.

## 7. Troubleshooting Cardinality Issues
- **Symptom:** Slow query performance.
  **Solution:** Check the execution plan to see if there are any cardinality estimation issues. Consider updating statistics or rewriting the query.
  
- **Symptom:** Incorrect results due to stale statistics.
  **Solution:** Use `UPDATE STATISTICS` or `sp_updatestats` to refresh the statistics.

## 8. Conclusion
Understanding cardinality is essential for database design and query optimization. Proper management of cardinality through statistics and indexing can significantly improve the performance of your SQL Server databases.

## 9. References
- [SQL Server Documentation](https://docs.microsoft.com/en-us/sql/sql-server/)
- [Cardinality Estimation in SQL Server](https://docs.microsoft.com/en-us/sql/relational-databases/sql-server-query-optimizer-cardinality-estimation)
